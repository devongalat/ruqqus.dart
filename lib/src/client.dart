import 'dart:async';
import 'dart:convert';

import 'package:event_dart/event_dart.dart';
import 'package:sprint/sprint.dart';

import 'package:ruqqus_dart/src/API.dart';
import 'package:ruqqus_dart/src/structs/primary.dart';
import 'package:ruqqus_dart/src/structs/submissions.dart';

/// The principal class for interacting with the Ruqqus API
class Client with EventEmitter {
  final Sprint log = Sprint('Client');

  /// Handler for HTTP calls to the API, as well as specific endpoints
  late final API api;

  /// Data required for refreshing the access token every hour
  late final Map<String, String> refreshData;

  /// Stored token that allows the client to access Ruqqus' endpoints
  String? accessToken;

  /// Keeps track of whether the client had already previously obtained
  /// an access token for when it needs to be refreshed
  bool isActive = false;

  /// Minimum interval between read requests
  static const Duration minimumReadInterval = const Duration(minutes: 1);

  /// Minimum interval between write requests
  static const Duration minimumWriteInterval = const Duration(seconds: 3);

  /// [clientId] - The ID of your approved application
  ///
  /// [clientSecret] - The key generated by Ruqqus for controlling the application
  ///
  /// [refreshToken] - The token obtained during authorisation of the application
  ///
  /// [userAgent] - (Optional) A string that helps identify who the user of the bot is
  ///
  /// [quietMode] - (Optional) If `true`, the library will not log any messages
  Client({
    required String clientId,
    required String clientSecret,
    required String refreshToken,
    String userAgent = 'Project utilizing ruqqus.dart',
    bool quietMode = false,
  }) {
    refreshData = {
      'client_id': clientId,
      'client_secret': clientSecret,
      'grant_type': 'refresh',
      'refresh_token': refreshToken,
    };

    log.quietMode = quietMode;

    api = API(this, refreshData, userAgent, quietMode: quietMode);
  }

  /// Ruqqus: "Access tokens expire one hour after they are issued.
  /// To maintain ongoing access, you will need to use the refresh token to obtain a new access token."
  Future login() async {
    final response = await api.post(API.grantUrl, body: refreshData);

    if (response == null || response.body.trim().isEmpty) {
      log.error(
          'Failed to obtain access token as Ruqqus returned an empty response');
      return;
    }

    // Received an unexpected HTML response
    if (response.body.startsWith('<!DOCTYPE html>')) {
      log.error(
          'Failed to connect to Ruqqus; check your internet connection, otherwise Ruqqus servers may be offline.');
      return;
    }

    final body = jsonDecode(response.body);

    accessToken = body['access_token']!;

    if (!isActive) {
      isActive = true;

      emit('ready');
      log.success('The bot is ready to interact with the Ruqqus API');
    } else {
      log.debug('Refreshed bot access token');
    }

    Future.delayed(Duration(minutes: 59, seconds: 55), () {
      login();
    });
  }

  /// Begins listening for submissions at with a delay [listeningDelay]
  ///
  /// [listeningDelay] must be longer than 1 minute to prevent flooding the Ruqqus servers
  Stream<Primary> listenForSubmissions<Submission extends Primary>({
    Duration listeningDelay = minimumReadInterval,
    List<String> accumulatedIds = const [],
  }) async* {
    if (listeningDelay.inSeconds < minimumReadInterval.inSeconds) {
      log.warning(
        'The provided interval does not meet the minimum duration of ${minimumReadInterval.inMinutes}'
        ' minute and has been automatically adjusted to it.',
      );
      listeningDelay = minimumReadInterval;
    }

    Timer.periodic(listeningDelay, (timer) async* {
      // Get all entries in /all
      final response = await api.get(
        Submission is Post ? '/all/listing' : '/front/comments',
        headers: {'sort': 'new'},
      );

      if (response == null) {
        log.warning('Failed to fetch most recent submissions');
        return;
      }

      final body = jsonDecode(response.body);

      // Converts _InternalLinkedHashMap<String, dynamic> to a List<dynamic>
      List<dynamic> receivedEntries = Map<String, dynamic>.from(body)['data'];

      // Iterates through the list of entries
      for (Map<String, dynamic> receivedEntry in receivedEntries) {
        // If the entry has already been seen before, ignore it
        if (accumulatedIds.contains(receivedEntry['id'])) {
          continue;
        }

        // Create an entry and stream the response
        final Primary entry = Submission is Post
            ? Post.from(api, receivedEntry)
            : Comment.from(api, receivedEntry);
        yield entry;
        accumulatedIds.add(entry.id!);
      }
    });
  }

  /// Constructs an authentication link
  static String obtainAuthURL({
    required String clientId,
    required String redirectUri,
    String state = 'ruqqus',
    required List<String> scopes,
    required bool isPermanent,
  }) {
    var scope = scopes.join(',');

    return '${API.host}/oauth/authorize'
        '?client_id=$clientId'
        '&redirect_uri=$redirectUri'
        '&state=$state'
        '&scope=$scope'
        '&permanent=$isPermanent';
  }
}
